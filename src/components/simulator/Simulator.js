import React, { useState } from 'react';
import { useLanguage } from '../../context/LanguageContext';
import { FaPlay, FaTint, FaFlask, FaSeedling } from 'react-icons/fa';
import './Simulator.css';

const Simulator = ({ setWaterLevel, selectedCrop }) => { // ðŸ›‘ ADD selectedCrop PROP HERE
    const [isSimulating, setIsSimulating] = useState(false);
    const [simulationStep, setSimulationStep] = useState(0);
    const [simulationResults, setSimulationResults] = useState(null);
    const [progress, setProgress] = useState(0);
    const [saveStatus, setSaveStatus] = useState(''); // New state for API status

    const { translate } = useLanguage();

    const simulationSteps = [
        translate('sim.steps.detect'),
        translate('sim.steps.calculateIrrigation'),
        translate('sim.steps.determineFertilizer'),
        translate('sim.steps.apply')
    ];

    // Utility function to introduce a delay
    const delay = ms => new Promise(res => setTimeout(res, ms));

    // --- NEW: Function to send data to Spring Boot Backend ---
    const saveSimulationData = async (results) => {

        // ðŸ›‘ CRITICAL: Data structure must match SensorDataRequest.java DTO
        const dataToSend = {
            // These mock values are fine, but ensure the names match the DTO
            temperature: 28,
            humidity: 65,

            // This is the data generated by the simulation
            soilMoisture: results.soilMoisture,
            waterLevel: results.waterLevel, // The DTO uses 'waterLevel'

            // ðŸ›‘ USE CORRECT FIELD NAME and ACTUAL CROP from state
            selectedCrop: selectedCrop || 'wheat' // Use the crop selected by the user
        };

        try {
            setSaveStatus(translate('sim.status.saving'));

            // ðŸ›‘ CRITICAL: The endpoint is /api/data/save
            const response = await fetch('/api/data/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(dataToSend)
            });

            if (response.ok) {
                setSaveStatus(translate('sim.status.success'));
                console.log("Data saved successfully!");
            } else {
                // Log the error response from the backend
                const errorData = await response.json().catch(() => ({ message: 'No JSON body' }));
                console.error("Backend Error:", response.status, errorData);
                setSaveStatus(translate('sim.status.fail') + ` (${response.status})`);
            }
        } catch (error) {
            console.error("Network or Fetch Error:", error);
            setSaveStatus(translate('sim.status.network_fail'));
        }
    };
    // -------------------------------------------------------------------

    const runSimulation = async () => {
        // Reset states
        setIsSimulating(true);
        setSimulationStep(0);
        setProgress(0);
        setSimulationResults(null);
        setSaveStatus(''); // Reset save status

        // --- Simulation Logic (using async/await for cleaner steps) ---
        await delay(1000);
        setProgress(25);
        setSimulationStep(1);

        await delay(1000);
        setProgress(50);
        setSimulationStep(2);

        await delay(1000);
        setProgress(75);
        setSimulationStep(3);

        await delay(1000);
        setProgress(100);

        // Generate random results
        const soilMoisture = Math.floor(Math.random() * 71) + 20;
        // The water applied value is needed to send to the backend
        const waterApplied = Math.floor(Math.random() * 20); // Simulating a smaller application value
        const fertilizerAmount = Math.floor(Math.random() * 51) + 10;

        const results = {
            soilMoisture,
            waterLevel: waterApplied, // The key must be waterLevel to match the DTO
            fertilizerAmount
        };

        setSimulationResults(results);

        // AUTOMATICALLY TRIGGER IRRIGATION (decrease tank)
        if (typeof setWaterLevel === "function") {
            setWaterLevel(prev => Math.max(0, prev - waterApplied)); // Use the simulated amount
        }

        // --- NEW: Save results to backend after simulation completes ---
        await saveSimulationData(results);

        await delay(1000);
        setIsSimulating(false);
    };

    return (
        <div className="simulator-container">
            <h2 className="simulator-title">{translate('simulator.title')}</h2>

            {/* ... JSX remains the same ... */}

            {isSimulating && (
                <div className="simulation-progress">
                    <div className="progress-bar-container">
                        <div
                            className="progress-bar"
                            style={{ width: `${progress}%` }}
                        ></div>
                    </div>
                    <p className="simulation-step">{simulationSteps[simulationStep]}</p>
                </div>
            )}

            {simulationResults && (
                <div className="simulation-results">
                    <h3>{translate('sim.resultsTitle')}</h3>

                    <div className="results-grid">
                        <div className="result-item">
                            <FaTint className="result-icon" />
                            <div className="result-value">{simulationResults.soilMoisture}%</div>
                            <div className="result-label">{translate('dashboard.soilMoisture')}</div>
                        </div>

                        <div className="result-item">
                            <FaFlask className="result-icon" />
                            <div className="result-value">{simulationResults.waterLevel} L</div>
                            <div className="result-label">{translate('sim.waterApplied')}</div>
                        </div>

                        <div className="result-item">
                            <FaSeedling className="result-icon" />
                            <div className="result-value">{simulationResults.fertilizerAmount} units</div>
                            <div className="result-label">{translate('sim.fertilizerApplied')}</div>
                        </div>
                    </div>

                    {/* NEW: Display save status */}
                    <p className={`save-status ${saveStatus.includes('success') ? 'text-success' : saveStatus.includes('fail') ? 'text-danger' : ''}`}>
                        {saveStatus}
                    </p>

                    {!isSimulating && (
                        <button
                            className="simulator-button restart-button"
                            onClick={runSimulation}
                        >
                            <FaPlay className="button-icon" /> {translate('sim.runAgain')}
                        </button>
                    )}
                </div>
            )}

            {/* The rest of your return statement goes here */}
        </div>
    );
};

export default Simulator;